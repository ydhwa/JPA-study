# JPA 소개

## 일반적인 DAO(데이터 접근 객체)를 사용하여 데이터를 조회하는 순서
1. 데이터 조회용 SQL을 작성한다.
2. JDBC API를 사용해서 SQL을 실행한다.
3. 조회 결과를 해당 데이터의 객체로 매핑한다.

## SQL을 직접 다룰 때 발생하는 문제점
- 데이터 접근 계층을 사용해서 SQL을 숨겨도 어쩔 수 없이 DAO를 열어서 어떤 SQL이 실행되는지 확인해야 한다. 즉, 진정한 의미의 계층 분할이 어렵다.
- 엔티티(비즈니스 요구사항을 모델링한 객체)를 신뢰할 수 없다.
- SQL에 의존적인 개발을 피하기 어렵다.

## JPA와 문제 해결
- JPA는 객체를 DB에 저장하고 관리할 때 개발자가 직접 SQL을 작성하는 것이 아니라 JPA가 제공하는 API를 사용하면 된다. (API 사용 시 JPA가 개발자 대신에 적절한 SQL을 생성해서 DB에 전달함)
- 객체지향에서는 추상화, 상속, 다형성과 같은 개념이 있는데 반해, 관계형 데이터베이스는 객체지향에서 얘기하는 개념이 없으며 데이터 중심으로 구조화되어 있고, 집합적인 사고를 요구한다. 객체와 관계형 데이터베이스는 지향하는 목적이 다르므로 기능과 표현 방법 역시 다르다. 이 때문에 객체 구조를 테이블 구조에 저장하는 데에는 한계가 있다.

### 패러다임의 불일치로 발생하는 문제
1. 상속
- 객체는 있으나 테이블에게는 없는 기능이다.
2. 연관관계
- 객체는 참조를 사용하는 반면, 테이블은 외래 키와 조인을 사용해서 연관된 테이블을 조회한다.
- 객체는 참조가 있는 방향으로만 조회할 수 있는 반면, 테이블은 외래 키 하나로 쌍방향 조인이 가능하다.
- JPA는 참조를 외래키로 변환하거나, 외래키를 참조로 변환하는 작업을 처리해준다.
3. 객체 그래프 탐색
- 객체에서 참조를 사용해서 원하는 정보를 얻을 때까지 탐색하는 과정을 객체 그래프 탐색이라고 한다.
- SQL을 직접 다루면 처음 실행하는 SQL에 따라 객체 그래프를 어디까지 탐색할 수 있는지 정해지지만, 언제 끊어질지 모를 객체 그래프를 함부로 탐색할 수는 없는 노릇이다.
- JPA는 연관된 객체를 사용하는 시점에 적절한 SELECT SQL을 실행하므로, JPA를 사용하면 연관된 객체를 신뢰하고 마음껏 조회할 수 있다.(지연 로딩: 실제 객체를 사용하는 시점까지 DB 조회를 미룸)
- JPA는 연관된 객체를 즉시 함께 조회할지, 아니면 실제 사용되는 시점에 지연해서 조회할지 간단한 설정으로 정의할 수 있다.
4. 비교
- DB: 기본 키의 값으로 각 row를 구분
- 객체: 동일성 비교(==, 객체 인스턴스의 주소 값 비교)와 동등성 비교(equals() 메소드, 객체 내부의 값 비교)의 두 가지 방법이 있다.
- JPA는 같은 트랜잭션일 때 같은 객체가 조회되는 것을 보장한다.


## JPA(Java Persistence API)란 무엇인가?
- Java 진영의 ORM 기술 표준으로, 어플리케이션과 JDBC 사이에서 동작한다.
- hibernate 기반으로 만들어진 Java의 ORM 기술 표준

### ORM(Object-Relational Mapping)
- 단순히 SQL을 개발자 대신 생성해줄 뿐만 아니라 객체와 관계형 데이터베이스를 매핑함으로써 패러다임의 불일치 문제를 개발자 대신 해결해준다.
- 객체 측면에서는 정교한 객체 모델링이 가능하고, 관계형 데이터베이스는 데이터베이스에 맞도록 모델링하면 된다. 어떻게 매핑하는지만 ORM 프레임워크에게 알려주면 된다.
- Java 진영에서는 hibernate 프레임워크가 가장 많이 사용된다.

### JPA를 사용해야 하는 이유
1. 생산성
- JPA를 사용하면 Java Collection에 객체를 저장하듯이 JPA에게 저장할 객체를 전달하면 되므로, 반복적인 코드와 CRUD용 SQL을 개발자가 직접 작성하지 않아도 된다.
- JPA에는 DDL(Data Definition Language)문을 자동으로 생성해주는 기능도 있다.
2. 유지보수
- SQL문을 직접 다루면 엔티티에 필드를 하나만 추가해도 코드를 많은 부분에서 변경해야 했지만, JPA를 사용하면 이런 과정을 JPA가 처리해 주기 때문에 수정해야 할 코드가 줄어든다.
- JPA가 패러다임의 불일치 문제를 해결해 주기 때문에 객체지향 언어가 가진 장점들을 활용해서 유연하고 유지보수하기 좋은 도메인 모델을 편리하게 설계할 수 있다.
3. 패러다임의 불일치 문제 해결
4. 성능
- JPA는 어플리케이션과 DB 사이에서 다양한 성능 최적화 기회를 제공한다.
5. 데이터 접근 추상화와 벤더 독립성
- 관계형 데이터베이스는 같은 기능도 벤더마다 사용법이 다른 경우가 많다.(ex) 페이징 처리)
- JPA는 어플리케이션과 DB 사이에 추상화된 데이터 접근 계층을 제공해서 어플리케이션이 특정 DB 기술에 종속되지 않도록 한다.
- DB 변경 시 JPA에게 다른 DB를 사용한다고 알려주기만 하면 된다.
- JPA를 사용하면 Local 개발 환경은 H2 데이터베이스를 사용하고, 개발이나 상용 환경은 Oracle이나 MySQL 데이터베이스를 사용할 수 있다.
6. 표준
- JPA는 Java 진영의 ORM 기술 표준이기 때문에, 표준을 사용하면 다른 구현 기술로 손쉽게 바꿀 수 있다.

### ETC.
- JPA는 다양한 성능 최적화 기능을 제공해서 잘 이해하고 사용하면 좋은 성능을 낼 수 있지만, 잘 이해하지 못하고 사용한다면 N+1 같은 문제(한 번 SQL을 실행해서 조회한 수만큼 N번 SQL을 추가로 실행하는 문제)로 성능 저하가 발생할 수 있다.
- JPA는 통계 쿼리같이 복잡한 쿼리보다는 실시간 처리용 쿼리에 더 최적화 되어있다. 복잡한 통계 쿼리의 경우, SQL을 직접 작성하는 것이 더 쉬운 경우가 많다. 따라서, JPA가 제공하는 네이티브 SQL을 사용하거나 MyBatis, Spring의 JdbcTemplate같은 SQL 매퍼 형태의 프레임워크를 혼용하는 것도 좋은 방법이다.
#### MyBatis와의 차이점
- MyBatis나 JdbcTemplate를 보통 SQL 매퍼라고 한다.(SQL 매퍼: 객체와 SQL을 매핑함)  
- SQL과 매핑할 객체를 지정하면 지루하게 반복되는 JDBC API 사용과 응답 결과를 객체로 매핑하는 일은 SQL 매퍼가 대신 처리해준다.
- 하지만 결국 개발자가 SQL을 직접 작성해야 하기 때문에 SQL에 의존하는 개발을 피할 수 없다.
- ORM의 경우, 객체와 테이블을 매핑만 하면 ORM 프레임워크가 SQL을 만들어서 DB와 관련된 처리를 해주므로 SQL에 의존하는 개발을 피할 수 있다.
#### 이해해야 할 내용
- 객체와 관계형 데이터베이스를 어떻게 매핑하는지 학습한 후에 JPA의 핵심 개념을 이해해야 한다.
- 영속성 컨텍스트에 대한 이해